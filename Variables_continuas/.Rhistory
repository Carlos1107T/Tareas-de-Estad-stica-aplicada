cat("----------------------------------------------------\n")
cat("• α < 1: La distribución tiene forma de J invertida:\n")
cat("  - Densidad máxima en x = 0\n")
cat("  - Tasa de falla decreciente en el tiempo\n")
cat("  - Apropiada para componentes con 'mortalidad infantil'\n\n")
cat("• α = 1: La distribución se reduce a la exponencial:\n")
cat("  - f(x) = λ e^{-λx}\n")
cat("  - Tasa de falla constante\n")
cat("  - Proceso sin memoria\n\n")
cat("• α > 1: La distribución tiene forma de campana asimétrica:\n")
cat("  - Moda positiva (se desplaza a la derecha cuando α aumenta)\n")
cat("  - Tasa de falla creciente\n")
cat("  - Apropiada para componentes que se desgastan con el tiempo\n\n")
cat("• α = 2: Caso especial - Distribución de Rayleigh\n")
cat("• α ≈ 3.6: La distribución se aproxima a la normal\n\n")
cat("Resumen del efecto de α:\n")
cat("- α controla la forma fundamental de la distribución\n")
cat("- Afecta la tasa de falla: decreciente (α<1), constante (α=1), creciente (α>1)\n")
cat("- Modifica la simetría y la curtosis de la distribución\n")
cat("- Determina la posición de la moda\n\n")
cat("b) EFECTO DEL PARÁMETRO DE ESCALA λ (con α constante):\n")
cat("-----------------------------------------------------\n")
cat("• λ actúa como parámetro de escala:\n")
cat("  - Valores grandes de λ comprimen la distribución hacia el origen\n")
cat("  - Valores pequeños de λ expanden la distribución hacia la derecha\n\n")
cat("• Efecto en medidas de tendencia central:\n")
cat("  - E(X) = (1/λ) Γ(1 + 1/α) → inversamente proporcional a λ\n")
cat("  - Mediana = (1/λ) (ln 2)^{1/α} → inversamente proporcional a λ\n")
cat("  - Moda = (1/λ) ((α-1)/α)^{1/α} (para α > 1) → inversamente proporcional a λ\n\n")
cat("• Efecto en dispersión:\n")
cat("  - Var(X) = (1/λ²) [Γ(1 + 2/α) - Γ²(1 + 1/α)] → inversamente proporcional a λ²\n")
cat("  - La desviación estándar es inversamente proporcional a λ\n\n")
cat("Interpretación práctica:\n")
cat("- λ está relacionado con la 'vida característica' del componente\n")
cat("- En confiabilidad: λ alto indica componentes con vida útil más corta\n")
cat("- λ representa el inverso de la escala natural de la variable\n\n")
cat("EJEMPLO NUMÉRICO:\n")
cat("Para α = 2 constante:\n")
lambda_ejemplos <- c(0.5, 1, 2)
for(lambda in lambda_ejemplos) {
medidas <- weibull_measures(2, lambda)
cat(sprintf("λ = %.1f: E(X) = %.3f, Mediana = %.3f, Moda = %.3f\n",
lambda, medidas$esperanza, medidas$mediana, medidas$moda))
}
#| label: resumen-parametros
#| fig-cap: "Resumen del Efecto de los Parámetros Weibull"
# Crear una visualización resumen
resumen_data <- expand.grid(
alpha = c(0.5, 1, 2, 3),
lambda = c(0.5, 1, 2)
)
df_resumen <- data.frame()
for(i in 1:nrow(resumen_data)) {
alpha <- resumen_data$alpha[i]
lambda <- resumen_data$lambda[i]
y <- dweibull(x, shape = alpha, scale = 1/lambda)
df_resumen <- rbind(df_resumen, data.frame(
x = x,
y = y,
alpha = alpha,
lambda = lambda,
curva = paste0("α=", alpha, ", λ=", lambda)
))
}
ggplot(df_resumen, aes(x = x, y = y, color = as.factor(alpha), linetype = as.factor(lambda))) +
geom_line(linewidth = 1) +
labs(title = "Resumen: Efecto Combinado de α y λ en la Distribución Weibull",
x = "x",
y = "f(x)",
color = "Parámetro de forma (α)",
linetype = "Parámetro de escala (λ)") +
theme_minimal() +
scale_color_brewer(palette = "Set1") +
facet_wrap(~alpha, scales = "free", labeller = label_both) +
theme(legend.position = "bottom")
#| label: ejercicio3-aplicacion
#| fig-cap: "Simulación Weibull(α=1.2, λ=0.8) - Histograma vs Densidad Teórica"
set.seed(123)
# Parámetros dados
alpha <- 1.2
lambda <- 0.8
n <- 1000
# a) Simular datos y calcular estadísticas muestrales
datos_simulados <- rweibull(n, shape = alpha, scale = 1/lambda)
media_muestral <- mean(datos_simulados)
varianza_muestral <- var(datos_simulados)
desviacion_muestral <- sd(datos_simulados)
# b) Calcular valores teóricos
weibull_measures <- function(alpha, lambda) {
esperanza <- (1/lambda) * gamma(1 + 1/alpha)
varianza <- (1/lambda^2) * (gamma(1 + 2/alpha) - gamma(1 + 1/alpha)^2)
mediana <- (1/lambda) * (log(2))^(1/alpha)
moda <- ifelse(alpha > 1, (1/lambda) * ((alpha - 1)/alpha)^(1/alpha), 0)
return(list(
esperanza = esperanza,
varianza = varianza,
desviacion = sqrt(varianza),
mediana = mediana,
moda = moda
))
}
teorico <- weibull_measures(alpha, lambda)
# c) Graficar histograma con densidad teórica
x_teorico <- seq(0, max(datos_simulados) * 1.2, length.out = 1000)
y_teorico <- dweibull(x_teorico, shape = alpha, scale = 1/lambda)
ggplot() +
# Histograma de datos simulados
geom_histogram(
data = data.frame(x = datos_simulados),
aes(x = x, y = ..density..),
bins = 30,
fill = "lightblue",
color = "black",
alpha = 0.7
) +
# Densidad teórica
geom_line(
data = data.frame(x = x_teorico, y = y_teorico),
aes(x = x, y = y),
color = "red",
linewidth = 1.2,
linetype = "solid"
) +
# Línea vertical para la media muestral
geom_vline(
xintercept = media_muestral,
color = "blue",
linewidth = 1,
linetype = "dashed"
) +
# Línea vertical para la media teórica
geom_vline(
xintercept = teorico$esperanza,
color = "darkred",
linewidth = 1,
linetype = "dashed"
) +
labs(
title = "Distribución Weibull - Datos Simulados vs Teóricos",
subtitle = paste("Weibull(α =", alpha, ", λ =", lambda, ") - n =", n),
x = "x",
y = "Densidad"
) +
theme_minimal() +
annotate("text",
x = max(datos_simulados) * 0.7,
y = max(y_teorico) * 0.9,
label = paste("Media muestral:", round(media_muestral, 4),
"\nMedia teórica:", round(teorico$esperanza, 4)),
color = "black",
size = 4,
hjust = 0) +
scale_x_continuous(limits = c(0, max(datos_simulados) * 1.1))
#| label: ejercicio3-comparacion
#| fig-cap: "Comparación Detallada: Datos Simulados vs Distribución Teórica"
# Crear una comparación más detallada
comparacion_detallada <- data.frame(
Metrica = c("Media", "Varianza", "Desviación Estándar", "Mediana"),
Muestral = c(
media_muestral,
varianza_muestral,
desviacion_muestral,
median(datos_simulados)
),
Teorico = c(
teorico$esperanza,
teorico$varianza,
teorico$desviacion,
teorico$mediana
),
Diferencia = c(
media_muestral - teorico$esperanza,
varianza_muestral - teorico$varianza,
desviacion_muestral - teorico$desviacion,
median(datos_simulados) - teorico$mediana
)
)
# Mostrar tabla de comparación
knitr::kable(
comparacion_detallada,
digits = 4,
caption = "Comparación entre Estadísticas Muestrales y Valores Teóricos"
)
#| label: ejercicio3-qqplot
#| fig-cap: "Gráfico Q-Q para Verificar el Ajuste Weibull"
# Gráfico Q-Q para verificar el ajuste
qq_data <- data.frame(
Teorico = qweibull(ppoints(n), shape = alpha, scale = 1/lambda),
Muestral = sort(datos_simulados)
)
ggplot(qq_data, aes(x = Teorico, y = Muestral)) +
geom_point(alpha = 0.6, color = "blue") +
geom_abline(slope = 1, intercept = 0, color = "red", linewidth = 1) +
labs(
title = "Gráfico Q-Q: Weibull(α=1.2, λ=0.8)",
x = "Cuantiles Teóricos",
y = "Cuantiles Muestrales"
) +
theme_minimal() +
annotate("text",
x = min(qq_data$Teorico),
y = max(qq_data$Muestral) * 0.9,
label = "Línea de referencia y = x",
color = "red",
hjust = 0)
library(ggplot2)
library(dplyr)
library(knitr)
library(gridExtra)
library(plotly)
library(kableExtra)
p_acierto <- 0.7
r_tiros <- 8
fallos_esperados <- r_tiros * (1 - p_acierto) / p_acierto
varianza_fallos <- r_tiros * (1 - p_acierto) / (p_acierto^2)
desv_std_fallos <- sqrt(varianza_fallos)
cat("EJERCICIO 5.2: Tiros libres de baloncesto\n")
cat("a) Modelo: Suma de", r_tiros, "variables geométricas ~ Binomial Negativa\n")
cat("b) Número esperado de tiros fallados:", fallos_esperados, "\n")
cat("   Varianza:", varianza_fallos, "\n")
cat("   Desviación estándar:", desv_std_fallos, "\n")
n_sim <- 1000
set.seed(123)
simulacion_fallos <- replicate(n_sim, {
geometricas <- rgeom(r_tiros, prob = p_acierto)
sum(geometricas)
})
binomial_negativa <- rnbinom(n_sim, size = r_tiros, prob = p_acierto)
fallos_sim_esperados <- mean(simulacion_fallos)
fallos_bn_esperados <- mean(binomial_negativa)
cat("c) Simulación (1000 sesiones):\n")
cat("   Media de fallos (suma geométricas):", fallos_sim_esperados, "\n")
cat("   Media de fallos (binomial negativa):", fallos_bn_esperados, "\n")
cat("   Diferencia con valor teórico:", abs(fallos_sim_esperados - fallos_esperados), "\n")
data_comparacion <- data.frame(
valores = c(simulacion_fallos, binomial_negativa),
metodo = rep(c("Suma de Geométricas", "Binomial Negativa"), each = n_sim)
)
grafico <- ggplot(data_comparacion, aes(x = valores, fill = metodo)) +
geom_histogram(alpha = 0.6, bins = 30, position = "identity") +
facet_wrap(~metodo, ncol = 1) +
labs(title = "Distribución de tiros fallados antes de 8 éxitos",
subtitle = paste("p =", p_acierto, ", r =", r_tiros, ", Nsim =", n_sim),
x = "Número de tiros fallados",
y = "Frecuencia") +
theme_minimal() +
theme(legend.position = "none") +
scale_fill_manual(values = c("#3498DB", "#E74C3C")) +
geom_vline(xintercept = fallos_esperados, linetype = "dashed", color = "red", linewidth = 1)
print(grafico)
stats_comparacion <- data.frame(
Método = c("Suma Geométricas", "Binomial Negativa", "Teórico"),
Media = c(mean(simulacion_fallos), mean(binomial_negativa), fallos_esperados),
Varianza = c(var(simulacion_fallos), var(binomial_negativa), varianza_fallos)
)
kable(stats_comparacion,
caption = "Comparación de estadísticas - Tiros fallados",
digits = 4,
align = "ccc") %>%
kable_styling(bootstrap_options = "striped")
library(ggplot2)
library(dplyr)
library(knitr)
library(gridExtra)
library(patchwork)
library(kableExtra)
lambda <- 8
inventario_actual <- 12
costo_mantenimiento <- 2
costo_venta_perdida <- 15
costo_adquisicion <- 10
# a) Probabilidad de quedarse sin existencias
prob_agotamiento_actual <- 1 - ppois(inventario_actual - 1, lambda)
# b) Inventario para P(agotamiento) < 5%
inventario_95 <- qpois(0.95, lambda)  # P(X ≤ k) ≥ 0.95
# c) Función para calcular costo esperado
calcular_costo_esperado <- function(inventario) {
k_max <- 50
costo_total <- 0
for (demanda in 0:k_max) {
prob <- dpois(demanda, lambda)
if (demanda <= inventario) {
costo_total <- costo_total + prob * (
costo_adquisicion * inventario +
costo_mantenimiento * (inventario - demanda)
)
} else {
costo_total <- costo_total + prob * (
costo_adquisicion * inventario +
costo_venta_perdida * (demanda - inventario)
)
}
}
return(costo_total)
}
costo_actual <- calcular_costo_esperado(inventario_actual)
# d) Encontrar nivel óptimo de inventario
niveles_inventario <- 0:20
costos_esperados <- sapply(niveles_inventario, calcular_costo_esperado)
inventario_optimo <- niveles_inventario[which.min(costos_esperados)]
costo_optimo <- min(costos_esperados)
cat("EJERCICIO 7.7: Optimización de inventario\n")
cat("Parámetros:\n")
cat("  λ =", lambda, "ventas promedio por día\n")
cat("  Inventario actual:", inventario_actual, "unidades\n")
cat("  Costo mantenimiento: $", costo_mantenimiento, "por unidad\n")
cat("  Costo venta perdida: $", costo_venta_perdida, "por unidad\n")
cat("  Costo adquisición: $", costo_adquisicion, "por unidad\n\n")
cat("a) Probabilidad de agotamiento (inventario =", inventario_actual, "):",
round(prob_agotamiento_actual, 4), "\n")
cat("b) Inventario para P(agotamiento) < 5%:", inventario_95, "unidades\n")
cat("   Verificación - P(X >", inventario_95, ") =",
round(1 - ppois(inventario_95, lambda), 4), "\n")
cat("c) Costo esperado diario (inventario actual): $", round(costo_actual, 2), "\n")
cat("d) Nivel óptimo de inventario:", inventario_optimo, "unidades\n")
cat("   Costo mínimo esperado: $", round(costo_optimo, 2), "\n\n")
cat("Análisis de diferentes niveles de inventario:\n")
tabla_analisis <- data.frame(
Inventario = niveles_inventario,
P_Agotamiento = round(1 - ppois(niveles_inventario, lambda), 4),
Costo_Esperado = round(sapply(niveles_inventario, calcular_costo_esperado), 2)
)
kable(tabla_analisis,
caption = "Análisis de niveles de inventario",
align = "ccc") %>%
kable_styling(bootstrap_options = "striped") %>%
row_spec(which.min(tabla_analisis$Costo_Esperado) + 1,
background = "#E8F5E8")  # Resaltar óptimo
cat("\nDesglose del costo óptimo (inventario =", inventario_optimo, "):\n")
costo_adq_optimo <- costo_adquisicion * inventario_optimo
cat("  Costo de adquisición: $", costo_adq_optimo, "\n")
costo_mant_esperado <- 0
for (demanda in 0:inventario_optimo) {
if (demanda <= inventario_optimo) {
costo_mant_esperado <- costo_mant_esperado +
dpois(demanda, lambda) * costo_mantenimiento * (inventario_optimo - demanda)
}
}
cat("  Costo esperado mantenimiento: $", round(costo_mant_esperado, 2), "\n")
costo_ventas_perdidas_esperado <- 0
for (demanda in (inventario_optimo + 1):50) {
costo_ventas_perdidas_esperado <- costo_ventas_perdidas_esperado +
dpois(demanda, lambda) * costo_venta_perdida * (demanda - inventario_optimo)
}
cat("  Costo esperado ventas perdidas: $", round(costo_ventas_perdidas_esperado, 2), "\n")
cat("  TOTAL: $", round(costo_adq_optimo + costo_mant_esperado + costo_ventas_perdidas_esperado, 2), "\n")
lambda <- 8
inventario_actual <- 12
costo_mantenimiento <- 2
costo_venta_perdida <- 15
costo_adquisicion <- 10
# a) Probabilidad de quedarse sin existencias
prob_agotamiento_actual <- 1 - ppois(inventario_actual - 1, lambda)
# b) Inventario para P(agotamiento) < 5%
inventario_95 <- qpois(0.95, lambda)  # P(X ≤ k) ≥ 0.95
# c) Función para calcular costo esperado
calcular_costo_esperado <- function(inventario) {
k_max <- 50
costo_total <- 0
for (demanda in 0:k_max) {
prob <- dpois(demanda, lambda)
if (demanda <= inventario) {
costo_total <- costo_total + prob * (
costo_adquisicion * inventario +
costo_mantenimiento * (inventario - demanda)
)
} else {
costo_total <- costo_total + prob * (
costo_adquisicion * inventario +
costo_venta_perdida * (demanda - inventario)
)
}
}
return(costo_total)
}
costo_actual <- calcular_costo_esperado(inventario_actual)
# d) Encontrar nivel óptimo de inventario
niveles_inventario <- 0:20
costos_esperados <- sapply(niveles_inventario, calcular_costo_esperado)
inventario_optimo <- niveles_inventario[which.min(costos_esperados)]
costo_optimo <- min(costos_esperados)
cat("EJERCICIO 7.7: Optimización de inventario\n")
cat("Parámetros:\n")
cat("  λ =", lambda, "ventas promedio por día\n")
cat("  Inventario actual:", inventario_actual, "unidades\n")
cat("  Costo mantenimiento: $", costo_mantenimiento, "por unidad\n")
cat("  Costo venta perdida: $", costo_venta_perdida, "por unidad\n")
cat("  Costo adquisición: $", costo_adquisicion, "por unidad\n\n")
cat("a) Probabilidad de agotamiento (inventario =", inventario_actual, "):",
round(prob_agotamiento_actual, 4), "\n")
cat("b) Inventario para P(agotamiento) < 5%:", inventario_95, "unidades\n")
cat("   Verificación - P(X >", inventario_95, ") =",
round(1 - ppois(inventario_95, lambda), 4), "\n")
cat("c) Costo esperado diario (inventario actual): $", round(costo_actual, 2), "\n")
cat("d) Nivel óptimo de inventario:", inventario_optimo, "unidades\n")
cat("   Costo mínimo esperado: $", round(costo_optimo, 2), "\n\n")
cat("Análisis de diferentes niveles de inventario:\n")
tabla_analisis <- data.frame(
Inventario = niveles_inventario,
P_Agotamiento = round(1 - ppois(niveles_inventario, lambda), 4),
Costo_Esperado = round(sapply(niveles_inventario, calcular_costo_esperado), 2)
)
kable(tabla_analisis,
caption = "Análisis de niveles de inventario",
align = "ccc") %>%
kable_styling(bootstrap_options = "striped") %>%
row_spec(which.min(tabla_analisis$Costo_Esperado) + 1,
background = "#E8F5E8")  # Resaltar óptimo
cat("\nDesglose del costo óptimo (inventario =", inventario_optimo, "):\n")
costo_adq_optimo <- costo_adquisicion * inventario_optimo
cat("  Costo de adquisición: $", costo_adq_optimo, "\n")
costo_mant_esperado <- 0
for (demanda in 0:inventario_optimo) {
if (demanda <= inventario_optimo) {
costo_mant_esperado <- costo_mant_esperado +
dpois(demanda, lambda) * costo_mantenimiento * (inventario_optimo - demanda)
}
}
cat("  Costo esperado mantenimiento: $", round(costo_mant_esperado, 2), "\n")
costo_ventas_perdidas_esperado <- 0
for (demanda in (inventario_optimo + 1):50) {
costo_ventas_perdidas_esperado <- costo_ventas_perdidas_esperado +
dpois(demanda, lambda) * costo_venta_perdida * (demanda - inventario_optimo)
}
cat("  Costo esperado ventas perdidas: $", round(costo_ventas_perdidas_esperado, 2), "\n")
cat("  TOTAL: $", round(costo_adq_optimo + costo_mant_esperado + costo_ventas_perdidas_esperado, 2), "\n")
library(ggplot2)
library(dplyr)
library(knitr)
library(gridExtra)
library(patchwork)
library(kableExtra)
lambda <- 8
inventario_actual <- 12
costo_mantenimiento <- 2
costo_venta_perdida <- 15
costo_adquisicion <- 10
# a) Probabilidad de quedarse sin existencias
prob_agotamiento_actual <- 1 - ppois(inventario_actual - 1, lambda)
# b) Inventario para P(agotamiento) < 5%
inventario_95 <- qpois(0.95, lambda)  # P(X ≤ k) ≥ 0.95
# c) Función para calcular costo esperado
calcular_costo_esperado <- function(inventario) {
k_max <- 50
costo_total <- 0
for (demanda in 0:k_max) {
prob <- dpois(demanda, lambda)
if (demanda <= inventario) {
costo_total <- costo_total + prob * (
costo_adquisicion * inventario +
costo_mantenimiento * (inventario - demanda)
)
} else {
costo_total <- costo_total + prob * (
costo_adquisicion * inventario +
costo_venta_perdida * (demanda - inventario)
)
}
}
return(costo_total)
}
costo_actual <- calcular_costo_esperado(inventario_actual)
# d) Encontrar nivel óptimo de inventario
niveles_inventario <- 0:20
costos_esperados <- sapply(niveles_inventario, calcular_costo_esperado)
inventario_optimo <- niveles_inventario[which.min(costos_esperados)]
costo_optimo <- min(costos_esperados)
cat("EJERCICIO 7.7: Optimización de inventario\n")
cat("Parámetros:\n")
cat("  λ =", lambda, "ventas promedio por día\n")
cat("  Inventario actual:", inventario_actual, "unidades\n")
cat("  Costo mantenimiento: $", costo_mantenimiento, "por unidad\n")
cat("  Costo venta perdida: $", costo_venta_perdida, "por unidad\n")
cat("  Costo adquisición: $", costo_adquisicion, "por unidad\n\n")
cat("a) Probabilidad de agotamiento (inventario =", inventario_actual, "):",
round(prob_agotamiento_actual, 4), "\n")
cat("b) Inventario para P(agotamiento) < 5%:", inventario_95, "unidades\n")
cat("   Verificación - P(X >", inventario_95, ") =",
round(1 - ppois(inventario_95, lambda), 4), "\n")
cat("c) Costo esperado diario (inventario actual): $", round(costo_actual, 2), "\n")
cat("d) Nivel óptimo de inventario:", inventario_optimo, "unidades\n")
cat("   Costo mínimo esperado: $", round(costo_optimo, 2), "\n\n")
cat("Análisis de diferentes niveles de inventario:\n")
tabla_analisis <- data.frame(
Inventario = niveles_inventario,
P_Agotamiento = round(1 - ppois(niveles_inventario, lambda), 4),
Costo_Esperado = round(sapply(niveles_inventario, calcular_costo_esperado), 2)
)
kable(tabla_analisis,
caption = "Análisis de niveles de inventario",
align = "ccc") %>%
kable_styling(bootstrap_options = "striped") %>%
row_spec(which.min(tabla_analisis$Costo_Esperado) + 1,
background = "#E8F5E8")  # Resaltar óptimo
cat("\nDesglose del costo óptimo (inventario =", inventario_optimo, "):\n")
costo_adq_optimo <- costo_adquisicion * inventario_optimo
cat("  Costo de adquisición: $", costo_adq_optimo, "\n")
costo_mant_esperado <- 0
for (demanda in 0:inventario_optimo) {
if (demanda <= inventario_optimo) {
costo_mant_esperado <- costo_mant_esperado +
dpois(demanda, lambda) * costo_mantenimiento * (inventario_optimo - demanda)
}
}
cat("  Costo esperado mantenimiento: $", round(costo_mant_esperado, 2), "\n")
costo_ventas_perdidas_esperado <- 0
for (demanda in (inventario_optimo + 1):50) {
costo_ventas_perdidas_esperado <- costo_ventas_perdidas_esperado +
dpois(demanda, lambda) * costo_venta_perdida * (demanda - inventario_optimo)
}
cat("  Costo esperado ventas perdidas: $", round(costo_ventas_perdidas_esperado, 2), "\n")
cat("  TOTAL: $", round(costo_adq_optimo + costo_mant_esperado + costo_ventas_perdidas_esperado, 2), "\n")
